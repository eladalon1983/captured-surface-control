<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta content="text/html; charset=utf-8" http-equiv="Content-Type" />
    <title>Captured Surface Control</title>
    <script class="remove" src="captured-surface-control.js" type="text/javascript"></script>
    <script src="https://www.w3.org/Tools/respec/respec-w3c" class="remove"></script>
  </head>
  <body>
    <section id="sotd"></section>

    <section id="abstract">
      <p>
        Consider a Web application <var>capturer</var> which has used
        {{MediaDevices/getDisplayMedia()}} to start capturing another [=display surface=] we call
        <var>capturee</var>. This specification introduces a set of APIs that allow
        <var>capturer</var> the following new capabilities:
      </p>
      <ul>
        <li>Read or set <var>capturee</var>'s [=zoom level=].</li>
        <li>
          Deliver a wheel event over <var>capturee</var>'s viewport at coordinates of
          <var>capturer</var>'s choosing.
        </li>
      </ul>
      <p>
        Initially, these are only specified for captured [=display surfaces=] of type [=display
        surface/browser=], but extensions to [=display surface/window=] and [=display
        surface/monitor=] [=display surfaces=] are considered.
      </p>
    </section>

    <section id="background">
      <h1>Background</h1>
      <p>
        Nearly all video-conferencing Web applications offer their users the ability to share
        [=display surfaces=] - typically a browser tab ([=display surface/browser=]), a native app's
        window ([=display surface/window=]), or an entire screen ([=display surface/monitor=]).
      </p>
      <p>
        Many of these applications also show the local user a "preview tile" with a video of the
        captured [=display surface=].
      </p>
      <p>
        All these applications suffer from one key drawback - if the user wishes to interact with a
        captured [=display surface=], the user must first switch to that surface, taking them away
        from the video-conferencing application. This presents a few issues:
      </p>
      <ol>
        <li>
          Users can't simultaneously interact with the captured application and see the videos of
          remote users.
        </li>
        <li>
          Users are burdened by the need to repeatedly switch between the video-conferencing
          application and the captured surface.
        </li>
        <li>
          Users are limited in their ability to see and interact with controls exposed by the
          video-conferencing application while they are interacting with the captured surface. A
          non-comprehensive list of examples of such controls includes - embedded chat applications,
          emoji reactions, "knock-ins" by users asking to join the call, and multimedia controls.
        </li>
        <!-- TODO: Reintroduce the following in a separate section focusing on potential future scope:
        <li>
          Local users who are presenting cannot delegate some limited control to remote
          participants. This leads to the all too familiar scenario, where remote users must beg the
          local user to change the slide or scroll a bit up/down.
        </li> -->
      </ol>
      <p>
        It bears mentioning that
        <a href="https://wicg.github.io/document-picture-in-picture/"
          >Document Picture-in-Picture</a
        >
        goes a long way towards addressing some of these issues. However, it not always a suitable
        solution, as not all use cases are adequately addressed by a floating window which will
        often be small, which obscures arbitrary other content on the screen, and whose size and
        positioning must be manually controlled by the user.
      </p>
    </section>

    <section id="feature-policy-integration">
      <h1>Permissions Policy Integration</h1>
      <p>
        This specification defines a [=policy-controlled feature=] identified by the string
        <dfn class="permission export"><code>"captured-surface-control"</code></dfn
        >. Its [=policy-controlled feature/default allowlist=] is <code>"self"</code>.
      </p>
      <p>
        Some of the APIs introduced in this specification may be invoked by any document and are not
        subject to any permissions policy. We define each such API an "ungated Captured Surface
        Control API", or for short, an <dfn>ungated API</dfn>.
      </p>
      <p>
        Some other APIs in introduced in this specification may only be called by documents that
        have the <code>"captured-surface-control"</code> permissions policy. We define each such API
        a "gated Captured Surface Control API", or for short, a <dfn>permission-gated API</dfn>.
      </p>
    </section>

    <section id="zoom">
      <h1>Zoom</h1>
      <section id="zoom-definition">
        <h2>Definition of Zoom</h2>
        <p>
          We define a concept of an integer "<dfn>zoom level</dfn>" that can be applied to [=display
          surfaces=] of any type, and which is independent of the user agent and the platform. It is
          expected that in the case of [=display surface/browser=] [=display surfaces=], this
          concept will match the concept of zoom level that user agents typically exposed to the
          user.
        </p>
        <ul>
          <li>
            The <dfn>default zoom level</dfn> of any [=display surface=] is defined to be 100. All
            implementations must support this value for all [=display surface=] of any type.
          </li>
          <li>
            Decreasing [=zoom level=] values represent "zooming out". The minimum theoretical value
            is 1; however, user agents may cap their support for "zooming out" at a larger values,
            with 100 being the largest permissible minimum value, representing lack of support for
            "zooming out".
          </li>
          <li>
            Increasing values represent "zooming in". This specification does not mandate a
            theoretical maximum. The smallest possible maximum is 100, which represents lack of
            support for "zooming in".
          </li>
        </ul>
        <p>
          For a given [=display surface=] of type <var>surfaceType</var>, we define the user agent's
          set of <dfn>supported zoom levels</dfn> for <var>surfaceType</var> as a non-empty set of
          integers including at least the [=default zoom level=] (100), and not including any
          integers lesser than 1.
        </p>
      </section>
      <section id="zoom-control-apis">
        <h2>Zoom-control APIs</h2>
        <pre class="idl">
          partial interface CaptureController {
            sequence&lt;long&gt; getSupportedZoomLevels();
            long getZoomLevel();
            Promise&lt;undefined&gt; setZoomLevel(long zoomLevel);
            attribute EventHandler oncapturedzoomlevelchange;
          };
        </pre>
        <dl data-link-for="CaptureController" data-dfn-for="CaptureController" class="methods">
          <dt><dfn>getSupportedZoomLevels()</dfn></dt>
          <dd>
            <p>
              This [=ungated API=] allows applications to discover the set of [=zoom levels=]
              supported by the user agent.
            </p>
            <p>When invoked, run the following steps:</p>
            <ol>
              <li>
                If [=this=] is not [=actively capturing=], [=exception/throw=] an
                "{{InvalidStateError}}" {{DOMException}}.
              </li>
              <li>
                Let <var>surfaceType</var> be [=this=].<a
                  data-cite="!screen-capture/#dfn-displaysurfacetype"
                  >[[\DisplaySurfaceType]]</a
                >.
              </li>
              <li>
                If <var>surfaceType</var> is not a [=supported display surface type=],
                [=exception/throw=] a "{{NotSupportedError}}" {{DOMException}}.
              </li>
              <li>
                Return a monotonically increasing sequence containing all of the values in the
                [=supported zoom levels=] for <var>surfaceType</var>.
              </li>
            </ol>
          </dd>
          <dt><dfn>getZoomLevel()</dfn></dt>
          <dd>
            <p>
              This [=ungated API=] allows applications to discover the captured [=display
              surface=]'s [=zoom level=].
            </p>
            <p>When invoked, run the following steps:</p>
            <ol>
              <li>
                If [=this=] is not [=actively capturing=], [=exception/throw=] an
                "{{InvalidStateError}}" {{DOMException}}.
              </li>
              <li>
                If [=this=].<a data-cite="!screen-capture/#dfn-displaysurfacetype"
                  >[[\DisplaySurfaceType]]</a
                >
                is not a [=supported display surface type=], [=exception/throw=] a
                "{{NotSupportedError}}" {{DOMException}}.
              </li>
              <li>
                Return [=this=].<a data-cite="!screen-capture/#dfn-source">[[\Source]]</a>'s [=zoom
                level=].
              </li>
            </ol>
          </dd>
          <dt><dfn>setZoomLevel()</dfn></dt>
          <dd>
            <p>
              This [=permission-gated API=] allows applications to set the captured [=display
              surface=]'s [=zoom level=].
            </p>
            <p>When invoked, run the following steps:</p>
            <ol>
              <li>
                If [=this=] is not [=actively capturing=], return a promise [=reject|rejected=] with
                a {{DOMException}} object whose {{DOMException/name}} attribute has the value
                {{InvalidStateError}}.
              </li>
              <li>
                Let <var>surfaceType</var> be [=this=].<a
                  data-cite="!screen-capture/#dfn-displaysurfacetype"
                  >[[\DisplaySurfaceType]]</a
                >.
              </li>
              <li>
                If <var>surfaceType</var> is not a [=display surface/browser=] or [=display
                surface/window=] [=display surface=], return a promise [=reject|rejected=] with a
                {{DOMException}} object whose {{DOMException/name}} attribute has the value
                {{NotSupportedError}}.
              </li>
              <li>Let <var>targetZoomLevel</var> be the method's first argument.</li>
              <li>
                If <var>targetZoomLevel</var> is not included in the user agent's set of [=supported
                zoom levels=] for <var>surfaceType</var>, return a promise [=reject|rejected=] with
                a {{DOMException}} object whose {{DOMException/name}} attribute has the value
                {{InvalidStateError}}.
              </li>
              <li>Let <var>P</var> be a new {{Promise}}.</li>
              <li>Run the following steps [=in parallel=]:</li>
              <li>
                <ol>
                  <li>
                    If the [=relevant global object=]'s [=navigable=]'s [=top-level traversable=]
                    does NOT have
                    <a data-cite="!HTML/#tlbc-system-focus">system focus</a>, [=reject=]
                    <var>P</var> with a new {{DOMException}} object whose {{DOMException/name}}
                    attribute has the value {{NotFoundError}} and abort these steps.
                  </li>
                  <li>
                    [=Request permission to use=] a {{PermissionDescriptor}} with its
                    {{PermissionDescriptor/name}} member set to
                    <code>"captured-surface-control"</code>. If the result of the request is
                    {{PermissionState/"denied"}}, [=reject=] <var>P</var> with a new
                    {{DOMException}} object whose {{DOMException/name}} is {{NotAllowedError}} and
                    abort these steps.
                  </li>
                  <li>
                    Set [=this=].<a data-cite="!screen-capture/#dfn-source">[[\Source]]</a>'s [=zoom
                    level=] to <var>targetZoomLevel</var>.
                  </li>
                  <!-- TODO: Mention the effect the prior step has on the relevant events. -->
                  <li>[=Resolve=] <var>P</var>.</li>
                </ol>
              </li>
              <li>Return <var>P</var>.</li>
            </ol>
          </dd>
          <dt><dfn>oncapturedzoomlevelchange</dfn></dt>
          <dd>TODO</dd>
        </dl>
      </section>
    </section>

    <section id="scrolling">
      <h1>Scroll</h1>
      <p>
        We introduce a mechanism by which capturing applications may deliver a synthetic
        <a href="https://w3c.github.io/uievents/#idl-wheelevent">wheel event</a> over the viewport
        of a captured [=display surface=].
      </p>
      <pre class="idl">
        dictionary CapturedWheelAction {
          long x = 0;
          long y = 0;
          long wheelDeltaX = 0;
          long wheelDeltaY = 0;
        };
      </pre>
      <dl data-link-for="CapturedWheelAction" data-dfn-for="CapturedWheelAction">
        <dt><dfn>x</dfn></dt>
        <dd>
          The horizontal offset of the point where the wheel event should be delivered. 0 represents
          the left edge of the viewport.
        </dd>
        <dt><dfn>y</dfn></dt>
        <dd>
          The vertical offset of the point where the wheel event should be delivered. 0 represents
          the upper edge of the viewport.
        </dd>
        <dt><dfn>wheelDeltaX</dfn></dt>
        <dd>The horizontal scroll amount, in pixels.</dd>
        <dt><dfn>wheelDeltaY</dfn></dt>
        <dd>The vertical scroll amount, in pixels.</dd>
      </dl>
      <pre class="idl">
        partial interface CaptureController {
          Promise&lt;undefined&gt; sendWheel(optional CapturedWheelAction action = {});
        };
      </pre>
      <dl data-link-for="CaptureController" data-dfn-for="CaptureController" class="methods">
        <dt><dfn>sendWheel()</dfn></dt>
        <dd>TODO</dd>
      </dl>
    </section>

    <section>
      <h1>Subroutines</h1>
      <p>
        To determine if a {{CaptureController}} <var>C</var> is <dfn>actively capturing</dfn>, run
        the following steps:
      </p>
      <ol>
        <!-- TODO: Fix the export of CaptureController's internal slots and use them. -->
        <li>
          Let <var>source</var> be <var>C</var>.<a data-cite="!screen-capture/#dfn-source"
            >[[\Source]]</a
          >.
        </li>
        <li>If <var>source</var> is <code>null</code>, return <code>false</code>.</li>
        <li>
          If <var>source</var> has been <a data-cite="GETUSERMEDIA#source-stopped">stopped</a>,
          return <code>false</code>.
        </li>
        <li>Return <code>true</code>.</li>
      </ol>
      <p>
        To determine if a [=display surface=] <var>surfaceType</var> is
        <dfn>supported display surface type</dfn>, run the following steps:
      </p>
      <ol>
        <li>If <var>surfaceType</var> is [=display surface/browser=], return <code>true</code>.</li>
        <li>Return <code>false</code>.</li>
      </ol>
      <div class="note">
        <p>Whether [=display surface/window=] should be supported is under discussion.</p>
      </div>
    </section>

    <section id="examples">
      <h1>Examples</h1>
      <p>TODO</p>
    </section>
  </body>
</html>
